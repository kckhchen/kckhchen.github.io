---
title: 貝氏統計如何做機率更新？
layout: post
date: 2025-06-13
math: "true"
categories: [zh]
---

上一篇文章中我試著用直覺的方式介紹了貝氏統計的哲學：先驗機率以及機率更新。這篇文章將會深入數學的部分，介紹貝氏統計如何善用機率函數的特性以及鼎鼎大名的貝氏定理，從先驗機率和概似函數的計算中，用簡單的方法推算出後驗機率。

## 核（kernel）是什麼？

在瞭解貝氏統計如何做機率更新之前，我們需要先重新認識機率函數。

一般來說，機率函數可以被拆解成兩個部分：核（kernel）以及歸一常數（normalizing constant）。以下方的高斯機率密度函數（或稱常態分配，normal distribution）為例：

\\[
\frac{1}{\sqrt{ 2\pi \sigma^{2} }} \boxed {\exp \left( -\frac{1}{2\sigma^{2}}(x-\mu)^{2} \right) }
\\]

上圖中方框內的就是高斯機率函數的核，方框外的則是歸一常數。核是一個機率函數的核心，它控制了機率函數會如何表現，然而歸一常數的存在，顧名思義，僅僅是為了確保機率函數的加總（或是積分）為 1，以符合機率函數的定義。也就是說，要分辨不同的機率函數，只需要認出他們的核即可，不同的機率函數就會有不同的核，而核定義好之後，我們只需要去計算核的積分或加總，如果不是 1，只要再除上一個歸一常數就可以了。

簡單來說，假設一個非負函數的 \\(f(x)\\) 的積分為 \\(c\\)，我們就可以定義 \\(f(x)/c\\) 為一個機率函數，因為：

\\[
\int \frac{f(x)}{c} \, dx = \frac{1}{c} \int f(x) \, dx = \frac{c}{c} = 1  
\\]

而要辨認出機率函數的核也很簡單：只要跟隨機變數有關的部分都是核，而可獨立分離出來的乘數就是歸一常數。我們可以簡單來看幾個例子。如 Gamma 分配：

\\[
\frac{\beta^{\alpha}}{\Gamma(\alpha)} \boxed{ x^{\alpha-1}e^{ -\beta x } }
\\]

或 Beta 分配：

\\[
\frac{\Gamma(\alpha) + \Gamma(\beta)}{\Gamma(\alpha+\beta)} \boxed{ x^{\alpha-1} (1-x)^{\beta-1}}
\\]

或 Poisson 分配：

\\[
\boxed{ \frac{1}{x!} \lambda^{x} } e^{ -\lambda }
\\]

圖中方框內與 \\(x\\) 有關、無法分離的部分，就是這些機率函數各自的核，而方框外的部分就是與 \\(x\\) 無關的歸一常數。而我們也發現，不同形式的核，也自然地會對應不同但唯一的歸一常數形式。

知道核可以做什麼呢？如上所述，不同的核代表著不同的機率函數，而剩下的部分（也就是歸一常數）都相對「不重要」，因此做計算時，如果事先就知道我的計算結果是一個機率函數，我就可以先把所有與 \\(x\\) 無關的部分拋棄不算。我只要在計算的最後認得我的核的長相，我就可以輕鬆把歸一常數反推出來，省去中間大量計算不重要常數的時間。

機率函數的這種特性在貝氏統計進行機率更新時，被利用得淋漓盡致。但在真正開始機率更新前，讓我們再來看看概似函數（likelihood），如果已經有統計基礎的你，下一節可以直接跳過。

## 什麼是概似函數？

概似函數和機率其實是同一個問題的兩面。機率關心的是「母體參數會如何影響實驗結果？」，而概似函數關心的是「有了實驗結果，我能怎麼推斷母體參數？」

拿最簡單的不公正硬幣實驗作為例子：某不公正硬幣出現正面的機率是 0.3，出現反面的機率是 0.7。此時，如果我擲硬幣 100 次，我會預期高機率出現約 30 次正面和 70 次反面，這就是機率；反過來說，如果我今天丟了某個不公正硬幣 100，觀察到 30 次正面和 70 次反面，我會猜測這個硬幣出現正面的機率很有可能是 0.3——這就是概似函數的核心。

如上所示，概似和機率是同一個問題的兩面，只是套用了不同的解讀方向，這點在概似函數的數學表現式上展露無遺：概似函數和機率密度函數長得一模一樣。

在獨立同分布（independent and identically distributed, \\(i.i.d.\\)）的實驗狀況下，\\(n\\) 個隨機變數的聯合機率分配，正是各自的機率密度函數乘積，也就是：

\\[
p(x_{1}, x_{2},\dots, x_{n} \mid \theta) = p(x_{1} \mid \theta) \times p(x_{2} \mid \theta) \times \dots \times p(x_{n} \mid \theta) = \prod_{i=1}^{n} p(x_{i} \mid \theta)
\\]

上面的公式可以被解讀為「給定參數 \\(\theta\\)，在進行多次實驗後，結果為 \\(x_{1}, \dots, x_{n}\\) 的機率為何？」。而其相對應的概似函數可以寫為下式：

\\[
\mathcal{L(\theta ; x_{1}, \dots,x_{n})} = \prod_{i=1}^{n} p(x_{i} \mid \theta)
\\]

沒錯，兩條公式壓根就長得一模一樣，只有一個地方變了——原本的機率函數是 \\(x\\) 的函數，現在成為了 \\(\theta\\) 的函數，也就是說，我不是在問給定 \\(\theta\\) 下，出現 \\(x_1, \dots, x_n\\) 的機率，而是「給定我看到的結果 \\(x_1, \dots ,x_n\\)，我的母體參數是 \\(\theta\\) 的機率為何？」我的目光焦點從實驗結果的機率轉向了母體參數的機率。

有了核、有了概似函數，我們就可以回到本次的主角——貝氏定理了。

## 利用核、概似函數以及貝氏定理進行機率更新

貝氏定理即為我們高中常見的：

\\[
\mathbb{P} \left( A \mid B \right) = \frac{\mathbb{P} \left( B \mid A \right)  \times \mathbb{P} \left( A \right) }{\mathbb{P} \left( B \right) }
\\]

這個定理貫穿了貝氏統計的機率更新手法，這也是貝氏統計得此名的原因。

具體而言，貝氏統計會先認定我的觀測數據是根據哪種機率分布出現（硬幣問題是伯努利分配、計數問題是 Poisson、身高是常態等等），並且想要推估這項分配的參數為何（如伯努利的機率 \\(\theta\\)，Poisson 的平均 \\(\lambda\\)，身高的平均 \\(\mu\\)），並且為這個參數選擇適合的先驗機率分配（至於何謂適合在這篇文章會提到）。

舉例而言，如果我想推論一個不公正硬幣出現正面的機率 \\(\theta\\)，我們已經知道硬幣實驗的結果會是參數為 \\(\theta\\) 伯努利分配（Bernoulli Distribution）：

\\[
p(X; \theta) = \theta^{X}(1-\theta)^{1-X}
\\]

我可以利用我的經驗、領域知識、以及信念為 \\(\theta\\) 選擇一個先驗 Beta 分配（上文中有 Beta 分配的長相。Beta 分配有兩個參數 \\(\alpha\\) 和 \\(\beta\\)，但不是現在的重點）。在我擲了 n 次硬幣，並觀察到結果後，我就可以獲得一個概似函數（likelihood）：

\\[
p(x_{1},\dots, x_{n} \mid \theta) = \prod_{i=1}^{n} p(x_{i} \mid \theta) = \prod_{i=1}^{n} \theta^{x_{i}}(1-\theta)^{1-x_{i}} = \theta^{\sum_{i=1}^{n} x_{i}}(1-\theta)^{n-\sum_{i=1}^{n} x_{i}}
\\]

到這裡，學過古典統計的你應該對這個 likelihood 十分面熟。古典統計會將這個函數取 log，並找到使 log-likelihood 最大的 \\(\theta\\)，也就是最大概似估計法 MLE。但這裡就是貝氏統計和古典統計分道揚鑣的地方。

在貝氏統計中，我們想要依據觀察到的結果，更新我的參數機率，形成後驗分配，而貝氏定理完美地派上用場：

\\[
p(\theta \mid x_{1}, \dots, x_{n}) = \frac{p(x_{1},\dots,x_{n} \mid \theta) \times p(\theta)}{p(x_{1},\dots,x_{n})}
\\]


我們驚喜地發現，等式右邊的分子正好就是我的 likelihood 以及先驗機率！雖然我不知道下方分母的全機率 \\(p(x_1,\dots,x_n)\\)，但由於它和我要推論的 \\(\theta\\) 沒有關係（特別注意，雖然 \\(\theta\\) 是 X 的參數，但我們這裡是想要推論 \\(\theta\\) 的機率分配，所以後驗機率中， \\(\theta\\) 是一個隨機變數，而 x1,...,xn 則變成了後驗機率中參數的一部分！），屬於歸一常數的一部分，我們可以將它捨去（反正我知道我要算的是機率，只要能夠認出核，我就可以推斷出歸一常數），因此等式變成：

\\[
p(\theta \mid x_{1}, \dots, x_{n}) \propto p(x_{1},\dots,x_{n} \mid \theta) \times p(\theta)
\\]

也就是後驗機率正比於先驗機率乘以 likelihood。這又是什麼呢？可以發現（一樣先無視歸一常數）：

\begin{align}
p(x_{1},\dots,x_{n} \mid \theta) \times p(\theta) &\propto \theta^{\sum_{i=1}^{n} x_{i}}(1-\theta)^{n-\sum_{i=1}^{n} x_{i}}\theta^{\alpha-1}(1-\theta)^{\beta-1} \\\\\\\\
&= \theta^{\alpha + \sum_{i=1}^{n} x_{i} -1} (1-\theta)^{\beta-n+\sum_{i=1}^{n} x_{i} - 1}
\end{align}

認出來了嗎？這串看似混亂的公式，正是一個 Beta 函數的核！我們把它寫得更乾淨一些：

\begin{align}
\theta^{\alpha + \sum_{i=1}^{n} x_{i}} (1-\theta)^{\beta-n+\sum_{i=1}^{n} x_{i} - 1} = \theta^{\alpha_{n} - 1}(1-\theta)^{\beta_{n}-1} \\\\\\\\
\text{where} \quad \alpha_{n} = \alpha + \sum_{i=1}^{n} x_{i} \quad \text{and} \quad \beta_{n} = \beta-n+\sum_{i=1}^{n} x_{i}
\end{align}

由於我們一開始要計算的後驗機率是一個機率函數，所以我們知道這個函數的加總必須為 1，但我們早就知道 Beta 函數的歸一常數長什麼樣子了，所以我們可以很輕鬆地把前面丟掉的常數用一個很乾淨的方式寫回來：

\\[
p(\theta \mid x_{1},\dots,x_{n}) = \frac{\Gamma(\alpha_{n}) + \Gamma(\beta_{n})}{\Gamma(\alpha_{n}+\beta_{n})} \theta^{\alpha_{n}-1} (1-\theta)^{\beta_{n}-1}
\\]

這樣我們就完成機率更新了！硬幣的後驗機率分配正好就是一個參數為 \\(\alpha_{n}\\) 和 \\(\beta_{n}\\) 的 Beta 分配。也就是，我們沒有改變分配的長相，只是更新的參數的大小。

哪有這麼好的事，先驗分配跟概似兩個八竿子打不著的機率相乘後，竟然得到一個乾乾淨淨，還長得跟先驗一樣的後驗分配？這當然不是巧合，而是在選擇先驗時就已經精打細算的設計。要能夠有這麼漂亮的結果，我們就得依照 likelihood 的長相，選擇一個合適的共軛先驗，我們會在下一篇文章中進一步討論。

## 結論

簡而言之，貝氏統計利用機率函數都有唯一的核以及歸一常數的特性，在機率更新時無視歸一常數，專注於核的計算，並在最後透過「認出」核，將歸一常數反推回來，完成簡單快速的機率更新。

當然，並不是每次的機率更新都可以這麼輕鬆寫意。更常出現的情況，是我們認不得後驗機率的核（又或者，那個核沒有常見、已被命名、有良好性質的對應機率函數）。上面的情況中的機率函數如果在硬算後有封閉解那還算好事，頂多就是計算麻煩了點，但有時我們甚至沒有辦法得知歸一常數長怎麼樣，也甚至無法對整個核積分，也就是我們甚至沒辦法得到漂亮的、加總為一的機率函數！這時候我們就要依靠更多後期發展出來的工具，如蒙地卡羅方法，來幫助我們估計後驗分配。

因此，這種方便的後驗機率更新方法只能說是貝氏統計中一種驚喜的特例，是由精明的統計學家找到的特殊解方，但卻不影響它的實用價值以及對於整個貝氏統計理論的奠基。

{% include mathjax.html %}